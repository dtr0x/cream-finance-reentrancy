from brownie import *
import json
from contextlib import redirect_stdout

def main():
    attacker = accounts.at(config['exploit']['sender'], force=True)
    attackContract = Contract.from_abi(
        'Attack',
        config['exploit']['receiver'],
        interface.IAttack.abi,
        attacker
    )
    args = attackContract.decode_input(config['exploit']['input'])[1]
    attackContract.start(*args)

    subcalls = history[-1].subcalls

    contractRegistry = dict()

    for call in subcalls:
        sender = call['from']
        receiver = call['to']

        if sender not in contractRegistry:
            fromContract = network.state._find_contract(sender)
            contractRegistry[sender] = fromContract
        else:
            fromContract = contractRegistry[sender]
        if fromContract:
            call['fromName'] = fromContract._name
        else:
            print(f'Contract at address {sender} not found')

        if receiver not in contractRegistry:
            toContract = network.state._find_contract(receiver)
            contractRegistry[receiver] = toContract
        else:
            toContract = contractRegistry[receiver]
        if toContract:
            call['toName'] = toContract._name
            if 'inputs' in call:
                inputs = call['inputs']
                for k,v in inputs.items():
                    # this is needed so subcalls can be serialized as json
                    if type(v).__name__ == 'HexString':
                        inputs[k] = '0x' + v.hex()
            # calldata exists and hasn't been decoded
            elif 'calldata' in call:
                data = call['calldata']
                if data[2:]:
                    try:
                        decoded = toContract.decode_input(data)
                        call['function'] = decoded[0]
                        call['inputs'] = decoded[1]
                    except ValueError as e:
                        print(f'Error in {toContract._name}:', str(e))
        else:
            print(f'Contract at address {receiver} not found')

    with open('txdata/subcalls.json', 'w') as f:
        json.dump(subcalls, f, indent=4)

    with open('txdata/trace.json', 'w') as f:
        json.dump(history[-1].trace, f, indent=4)

    with redirect_stdout(open('txdata/calltrace.out', 'w')) as f:
        history[-1].call_trace(True)

    # save sources
    allContracts = list([v for v in contractRegistry.values() if v])
    for c in allContracts:
        name = c._name
        sources = c._sources
        if len(sources) > 0:
            for filename, source in sources.items():
                filename = 'contracts/nocompile/_' + filename.split('/')[-1]
                with open(filename, 'w') as f:
                    f.write(source)
        else:
            print(f'No sources found for contract {name}')
